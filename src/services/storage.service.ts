import { Express } from 'express'
import path from 'path'
import fs from 'fs/promises'
import { HttpException } from '../utils/HttpException'

/**
 * Defines the contract for any storage service.
 * This interface allows us to easily swap out the local storage for a cloud-based
 * one (like S3) in the future without changing the business logic that uses it.
 */
export interface IStorageService {
  uploadAudioFile(file: Express.Multer.File | undefined): string
  deleteAudioFile(filePath: string): Promise<void>
}

/**
 * LocalStorageService handles file uploads and storage on the local server filesystem.
 * This implementation is suitable for development environments.
 */
class LocalStorageService implements IStorageService {
  /**
   * In the local storage strategy, the file is already saved by multer's diskStorage.
   * This method's responsibility is to validate the file's existence and return a
   * standardized path that can be stored in the database.
   * @param file The file object provided by multer.
   * @returns A promise that resolves to the public-facing path of the uploaded file.
   */
  public uploadAudioFile(file: Express.Multer.File | undefined): string {
    if (!file) {
      throw new HttpException(400, 'No audio file was uploaded.')
    }

    // The `file.filename` is generated by our multer.diskStorage configuration.
    // We will store a relative path in the database which makes it easy
    // to serve files statically or migrate later.
    // Example: '/uploads/audio-1629888000000-123456789.wav'
    const relativePath = `/uploads/${file.filename}`
    return relativePath
  }

  /**
   * Deletes a file from the local filesystem.
   * @param filePath The relative path to the file (e.g., '/uploads/audio-123.wav').
   */
  public async deleteAudioFile(filePath: string): Promise<void> {
    try {
      // Construct the full absolute path to the file to be deleted.
      // We assume the filePath starts with '/uploads/'.
      const absolutePath = path.join(
        path.join(process.cwd(), 'public/uploads'),
        filePath,
      )
      await fs.unlink(absolutePath)
    } catch (error: any) {
      // If the file doesn't exist (ENOENT), it means it might have been already
      // deleted or never existed. In this case, we don't need to throw an error.
      // For any other error, we log it.
      if (error.code !== 'ENOENT') {
        console.error(
          `Error deleting file from local storage: ${filePath}`,
          error,
        )
        // Optionally re-throw if you want the caller to handle it
        // throw new HttpException(500, `Could not delete file: ${filePath}`);
      }
    }
  }
}

// Export a singleton instance of the service.
// This ensures we use the same instance throughout the application.
export const storageService = new LocalStorageService()
